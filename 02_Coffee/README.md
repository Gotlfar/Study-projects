# Содержание <br>
[Условия задачи](#T1) <br>
[Решение задачи](#T2) <br>

<br><a name="T1"></a> 
## Условия задачи
На фоне снижения урожайности кофейных плантаций из-за глобального потепления ваша компания решила разработать новый сорт кофейного дерева, и первые образцы уже были отправлены на плантации. Пришло время оценить результаты проделанной работы.

### Материалы
У вас есть файл с данными о собранном за последние 5 лет урожае. Урожай с новых деревьев стали собирать только в прошлом году. Вам нужно проверить, выросла ли урожайность кофейных деревьев. Чтобы окупить вложенные в разработку средства, компания ожидает прирост средней урожайности минимум на 20 кг. В качестве уровня значимости используйте значение 0,05, а для мощности — 0,8.

### Стек
- Python
- Figma
<br><a name="T2"></a> 
## Решение задачи
[Файл Python](https://github.com/Gotlfar/Study-projects/blob/main/01_Bakery/Булат_Мигранов_Проект_1.xlsx)
1. Импортировал файл с данными об урожайности кофе.
2. Преобразовал данные: Проверив, нет ли в данных пустых строк `dropna()` или аномальных значений (определил среднее значение по медиане, далее проводил замену значений `loc[df['harvest']>500, 'harvest']`). Установил корректный формат данных
`df['month'] = pd.to_datetime(df['month'])` и разделил данные на старые `df.loc[df['month'] < '2023-01-01']` и новые `df.loc[df['month'] >= '2023-01-01']`
3. Определил стандартное отклонение по историческим данным `old_data['harvest'].std()` и минимально детектируемый эффект `mde = 20 / st # 20 кг дано по условию`. Далее определил размер выборки `TTestIndPower().solve_power(effect_size=mde, alpha=0.05, power=0.8)`
4. На основе данных о нужной выборке, создаю отдельно датафрейм в котором определяю количество пользователей в каждой группе по дате с накоплением `user_count_by_date = new_data.groupby(['month', 'sort']).size().reset_index(name='count')
user_count_by_date['cum_count'] = user_count_by_date.groupby('sort')['count'].cumsum()`. Далее нахожу минимальные даты, когда количество пользователей в каждой группе достигает sample_size `group_a_sample_date = user_count_by_date[user_count_by_date['sort'] == 'new'].loc[user_count_by_date['cum_count'] >= sample_size, 'month'].min()
group_b_sample_date = user_count_by_date[user_count_by_date['sort'] == 'old'].loc[user_count_by_date['cum_count'] >= sample_size, 'month'].min()`. Выбираю максимульную дату чтобы обе группы достигли необходимого размера выборки и фильтрую датафрейм по этой дате.
5. Провожу t-тест `t_test_result = sp.ttest_ind(
    ab_df['harvest'].loc[ab_df['sort'] == 'new'],
    ab_df['harvest'].loc[ab_df['sort'] == 'old']
)`
6. Cоздаю визуализацию с помощью библиотеки `matplotlib` определяя среднее значение урожая по сортам, динамику урожая за весь период и распределения урожая за последний год.
7. Сформировал выводы оформив [презентацию](https://github.com/Gotlfar/Study-projects/blob/main/02_Coffee/02_Coffee_PR.pdf)
